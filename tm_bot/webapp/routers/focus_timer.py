"""
Focus timer / Pomodoro endpoints.
"""

from datetime import datetime, timedelta
from typing import Optional
from fastapi import APIRouter, HTTPException, Depends, Request
from ..dependencies import get_current_user, get_settings_repo
from ..schemas import (
    StartFocusRequest, FocusSessionResponse, PauseFocusRequest,
    ResumeFocusRequest, StopFocusRequest
)
from repositories.sessions_repo import SessionsRepository
from repositories.promises_repo import PromisesRepository
from services.sessions import SessionsService
from repositories.actions_repo import ActionsRepository
from models.models import Session
from models.enums import SessionStatus
from utils.logger import get_logger
from db.postgres_db import dt_to_utc_iso

router = APIRouter(prefix="/api/focus", tags=["focus"])
logger = get_logger(__name__)


def get_sessions_service(request: Request) -> SessionsService:
    """Get sessions service instance."""
    sessions_repo = SessionsRepository(request.app.state.root_dir)
    actions_repo = ActionsRepository(request.app.state.root_dir)
    return SessionsService(sessions_repo, actions_repo)


def session_to_response(session: Session, promise_text: Optional[str] = None) -> FocusSessionResponse:
    """Convert Session model to FocusSessionResponse."""
    now = datetime.now()
    elapsed_seconds = None
    if session.status in [SessionStatus.RUNNING.value, SessionStatus.PAUSED.value]:
        elapsed_seconds = int((now - session.started_at).total_seconds() - session.paused_seconds_total)
        elapsed_seconds = max(0, elapsed_seconds)
    
    # Convert expected_end_utc to UTC ISO string
    expected_end_utc_str = ""
    if session.expected_end_utc:
        # If timezone-naive, assume it's already in UTC
        if session.expected_end_utc.tzinfo is None:
            expected_end_utc_str = session.expected_end_utc.isoformat() + "Z"
        else:
            # Convert to UTC
            from zoneinfo import ZoneInfo
            utc_dt = session.expected_end_utc.astimezone(ZoneInfo("UTC"))
            expected_end_utc_str = utc_dt.isoformat().replace('+00:00', 'Z')
    
    return FocusSessionResponse(
        session_id=session.session_id,
        promise_id=session.promise_id,
        promise_text=promise_text,
        status=session.status,
        started_at=session.started_at.isoformat(),
        expected_end_utc=expected_end_utc_str,
        planned_duration_minutes=session.planned_duration_minutes or 0,
        timer_kind=session.timer_kind or "focus",
        elapsed_seconds=elapsed_seconds,
    )


@router.post("/start", response_model=FocusSessionResponse)
async def start_focus(
    request: Request,
    focus_request: StartFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Start a new focus session. If user has an active session, it will be aborted first."""
    try:
        sessions_service = get_sessions_service(request)
        promises_repo = PromisesRepository(request.app.state.root_dir)
        
        # Verify promise exists
        promise = promises_repo.get_promise(user_id, focus_request.promise_id)
        if not promise:
            raise HTTPException(status_code=404, detail="Promise not found")
        
        # Enforce single active session: abort any existing active session
        active_session = sessions_service.sessions_repo.get_current_active_session(user_id)
        if active_session:
            logger.info(f"Aborting existing active session {active_session.session_id} for user {user_id}")
            sessions_service.abort(user_id, active_session.session_id)
        
        # Calculate expected end time
        now = datetime.now()
        duration_minutes = focus_request.duration_minutes
        expected_end = now + timedelta(minutes=duration_minutes)
        
        # Create session with timer fields
        session = Session(
            session_id="",  # Will be generated by start()
            user_id=str(user_id),
            promise_id=focus_request.promise_id,
            status=SessionStatus.RUNNING.value,
            started_at=now,
            last_state_change_at=now,
            expected_end_utc=expected_end,
            planned_duration_minutes=duration_minutes,
            timer_kind="focus",
        )
        
        # Use sessions_service.start() but then update with timer fields
        created_session = sessions_service.start(user_id, focus_request.promise_id)
        
        # Update session with timer fields
        created_session.expected_end_utc = expected_end
        created_session.planned_duration_minutes = duration_minutes
        created_session.timer_kind = "focus"
        sessions_service.sessions_repo.update_session(created_session)
        
        return session_to_response(created_session, promise.text)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error starting focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to start focus session: {str(e)}")


@router.get("/current", response_model=Optional[FocusSessionResponse])
async def get_current_focus(
    request: Request,
    user_id: int = Depends(get_current_user)
):
    """Get the current active focus session, if any."""
    try:
        sessions_service = get_sessions_service(request)
        sessions_repo = sessions_service.sessions_repo
        promises_repo = PromisesRepository(request.app.state.root_dir)
        
        active_session = sessions_repo.get_current_active_session(user_id)
        if not active_session:
            return None
        
        # Get promise text
        promise = promises_repo.get_promise(user_id, active_session.promise_id)
        promise_text = promise.text if promise else None
        
        return session_to_response(active_session, promise_text)
        
    except Exception as e:
        logger.exception(f"Error getting current focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get current focus session: {str(e)}")


@router.post("/pause", response_model=FocusSessionResponse)
async def pause_focus(
    request: Request,
    pause_request: PauseFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Pause the current focus session."""
    try:
        sessions_service = get_sessions_service(request)
        promises_repo = PromisesRepository(request.app.state.root_dir)
        
        session = sessions_service.pause(user_id, pause_request.session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found or cannot be paused")
        
        promise = promises_repo.get_promise(user_id, session.promise_id)
        promise_text = promise.text if promise else None
        
        return session_to_response(session, promise_text)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error pausing focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to pause focus session: {str(e)}")


@router.post("/resume", response_model=FocusSessionResponse)
async def resume_focus(
    request: Request,
    resume_request: ResumeFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Resume a paused focus session."""
    try:
        sessions_service = get_sessions_service(request)
        promises_repo = PromisesRepository(request.app.state.root_dir)
        
        session = sessions_service.resume(user_id, resume_request.session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found or cannot be resumed")
        
        promise = promises_repo.get_promise(user_id, session.promise_id)
        promise_text = promise.text if promise else None
        
        return session_to_response(session, promise_text)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error resuming focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to resume focus session: {str(e)}")


@router.post("/stop", response_model=dict)
async def stop_focus(
    request: Request,
    stop_request: StopFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Stop/abort the current focus session (does not log time)."""
    try:
        sessions_service = get_sessions_service(request)
        
        session = sessions_service.abort(user_id, stop_request.session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found or cannot be stopped")
        
        return {"status": "success", "message": "Focus session stopped"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error stopping focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to stop focus session: {str(e)}")
