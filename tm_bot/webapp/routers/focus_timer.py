"""
Focus timer / Pomodoro endpoints.
"""

from datetime import datetime, timedelta
from typing import Optional
from fastapi import APIRouter, HTTPException, Depends, Request
from ..dependencies import get_current_user, get_settings_repo
from ..schemas import (
    StartFocusRequest, FocusSessionResponse, PauseFocusRequest,
    ResumeFocusRequest, StopFocusRequest
)
from repositories.sessions_repo import SessionsRepository
from repositories.promises_repo import PromisesRepository
from services.sessions import SessionsService
from repositories.actions_repo import ActionsRepository
from models.models import Session
from models.enums import SessionStatus
from utils.logger import get_logger
from db.postgres_db import dt_to_utc_iso

router = APIRouter(prefix="/api/focus", tags=["focus"])
logger = get_logger(__name__)


def get_sessions_service(request: Request) -> SessionsService:
    """Get sessions service instance."""
    sessions_repo = SessionsRepository()
    actions_repo = ActionsRepository()
    return SessionsService(sessions_repo, actions_repo)


def session_to_response(session: Session, promise_text: Optional[str] = None) -> FocusSessionResponse:
    """Convert Session model to FocusSessionResponse."""
    now = datetime.now()
    elapsed_seconds = None
    if session.status in [SessionStatus.RUNNING.value, SessionStatus.PAUSED.value]:
        elapsed_seconds = int((now - session.started_at).total_seconds() - session.paused_seconds_total)
        elapsed_seconds = max(0, elapsed_seconds)
    
    # Convert expected_end_utc to UTC ISO string
    expected_end_utc_str = ""
    if session.expected_end_utc:
        # If timezone-naive, assume it's already in UTC
        if session.expected_end_utc.tzinfo is None:
            expected_end_utc_str = session.expected_end_utc.isoformat() + "Z"
        else:
            # Convert to UTC
            from zoneinfo import ZoneInfo
            utc_dt = session.expected_end_utc.astimezone(ZoneInfo("UTC"))
            expected_end_utc_str = utc_dt.isoformat().replace('+00:00', 'Z')
    
    return FocusSessionResponse(
        session_id=session.session_id,
        promise_id=session.promise_id,
        promise_text=promise_text,
        status=session.status,
        started_at=session.started_at.isoformat(),
        expected_end_utc=expected_end_utc_str,
        planned_duration_minutes=session.planned_duration_minutes or 0,
        timer_kind=session.timer_kind or "focus",
        elapsed_seconds=elapsed_seconds,
    )


@router.post("/start", response_model=FocusSessionResponse)
async def start_focus(
    request: Request,
    focus_request: StartFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Start a new focus session. If user has an active session, it will be aborted first."""
    try:
        sessions_service = get_sessions_service(request)
        promises_repo = PromisesRepository()
        
        # Verify promise exists
        promise = promises_repo.get_promise(user_id, focus_request.promise_id)
        if not promise:
            raise HTTPException(status_code=404, detail="Promise not found")
        
        # Enforce single active session: abort any existing active session
        active_session = sessions_service.sessions_repo.get_current_active_session(user_id)
        if active_session:
            logger.info(f"Aborting existing active session {active_session.session_id} for user {user_id}")
            sessions_service.abort(user_id, active_session.session_id)
        
        # Calculate expected end time
        now = datetime.now()
        duration_minutes = focus_request.duration_minutes
        expected_end = now + timedelta(minutes=duration_minutes)
        
        logger.info(f"Starting focus session for user {user_id}, promise {focus_request.promise_id}, "
                   f"duration: {duration_minutes} minutes, expected_end (local): {expected_end}")
        
        # Create session with timer fields
        session = Session(
            session_id="",  # Will be generated by start()
            user_id=str(user_id),
            promise_id=focus_request.promise_id,
            status=SessionStatus.RUNNING.value,
            started_at=now,
            last_state_change_at=now,
            expected_end_utc=expected_end,
            planned_duration_minutes=duration_minutes,
            timer_kind="focus",
        )
        
        # Use sessions_service.start() but then update with timer fields
        created_session = sessions_service.start(user_id, focus_request.promise_id)
        
        # Update session with timer fields
        created_session.expected_end_utc = expected_end
        created_session.planned_duration_minutes = duration_minutes
        created_session.timer_kind = "focus"
        sessions_service.sessions_repo.update_session(created_session)
        
        logger.info(f"Created focus session {created_session.session_id} with expected_end_utc: {created_session.expected_end_utc}")
        
        return session_to_response(created_session, promise.text)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error starting focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to start focus session: {str(e)}")


@router.get("/current", response_model=Optional[FocusSessionResponse])
async def get_current_focus(
    request: Request,
    user_id: int = Depends(get_current_user)
):
    """Get the current active focus session, if any."""
    try:
        sessions_service = get_sessions_service(request)
        sessions_repo = sessions_service.sessions_repo
        promises_repo = PromisesRepository()
        
        active_session = sessions_repo.get_current_active_session(user_id)
        if not active_session:
            return None
        
        # Get promise text
        promise = promises_repo.get_promise(user_id, active_session.promise_id)
        promise_text = promise.text if promise else None
        
        return session_to_response(active_session, promise_text)
        
    except Exception as e:
        logger.exception(f"Error getting current focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get current focus session: {str(e)}")


@router.post("/pause", response_model=FocusSessionResponse)
async def pause_focus(
    request: Request,
    pause_request: PauseFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Pause the current focus session."""
    try:
        sessions_service = get_sessions_service(request)
        promises_repo = PromisesRepository()
        
        session = sessions_service.pause(user_id, pause_request.session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found or cannot be paused")
        
        promise = promises_repo.get_promise(user_id, session.promise_id)
        promise_text = promise.text if promise else None
        
        return session_to_response(session, promise_text)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error pausing focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to pause focus session: {str(e)}")


@router.post("/resume", response_model=FocusSessionResponse)
async def resume_focus(
    request: Request,
    resume_request: ResumeFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Resume a paused focus session."""
    try:
        sessions_service = get_sessions_service(request)
        promises_repo = PromisesRepository()
        
        session = sessions_service.resume(user_id, resume_request.session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found or cannot be resumed")
        
        promise = promises_repo.get_promise(user_id, session.promise_id)
        promise_text = promise.text if promise else None
        
        return session_to_response(session, promise_text)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error resuming focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to resume focus session: {str(e)}")


@router.post("/stop", response_model=dict)
async def stop_focus(
    request: Request,
    stop_request: StopFocusRequest,
    user_id: int = Depends(get_current_user)
):
    """Stop/abort the current focus session (does not log time)."""
    try:
        sessions_service = get_sessions_service(request)
        
        session = sessions_service.abort(user_id, stop_request.session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found or cannot be stopped")
        
        return {"status": "success", "message": "Focus session stopped"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error stopping focus session for user {user_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to stop focus session: {str(e)}")


@router.get("/debug/check-overdue")
async def debug_check_overdue(
    request: Request,
    user_id: int = Depends(get_current_user)
):
    """Debug endpoint to check for overdue sessions for the current user."""
    try:
        from db.postgres_db import utc_now_iso
        from datetime import datetime
        
        sessions_repo = SessionsRepository()
        
        # Get current session
        current_session = sessions_repo.get_current_active_session(user_id)
        
        # Get all overdue sessions (for all users, but we'll filter)
        overdue_sessions = sessions_repo.list_overdue_sessions_needing_notification()
        
        # Filter to current user
        user_overdue = [s for s in overdue_sessions if int(s.user_id) == user_id]
        
        result = {
            "now_utc": utc_now_iso(),
            "current_session": None,
            "total_overdue_all_users": len(overdue_sessions),
            "user_overdue_count": len(user_overdue),
            "user_overdue_sessions": []
        }
        
        if current_session:
            result["current_session"] = {
                "session_id": current_session.session_id,
                "status": current_session.status,
                "expected_end_utc": current_session.expected_end_utc.isoformat() if current_session.expected_end_utc else None,
                "planned_duration_minutes": current_session.planned_duration_minutes,
                "notified_at_utc": current_session.notified_at_utc.isoformat() if current_session.notified_at_utc else None,
                "is_overdue": current_session.expected_end_utc and current_session.expected_end_utc <= datetime.now() if current_session.expected_end_utc else False,
            }
        
        for session in user_overdue:
            result["user_overdue_sessions"].append({
                "session_id": session.session_id,
                "expected_end_utc": session.expected_end_utc.isoformat() if session.expected_end_utc else None,
                "planned_duration_minutes": session.planned_duration_minutes,
                "status": session.status,
                "notified_at_utc": session.notified_at_utc.isoformat() if session.notified_at_utc else None,
            })
        
        return result
    except Exception as e:
        logger.exception(f"Error in debug check overdue: {e}")
        raise HTTPException(status_code=500, detail=f"Debug check failed: {str(e)}")
